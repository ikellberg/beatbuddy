## Ревью плана: US-004 Регистрация ударов с реального датчика

### Вердикт: Требует доработки (улучшен после первого ревью)

**Дата проверки:** 2026-02-05  
**Версия плана:** Обновлена после первого ревью

### Соответствие архитектуре (project_state.md)

✅ **Соответствует структуре проекта:**
- План использует существующую архитектуру: SensorManager.js как фабрика, папка `sensors/` для реализаций
- Соответствует паттерну KeyboardSensor.js (который уже реализован)
- Использует Web Audio API, что согласуется с MetronomeEngine.js

✅ **Учитывает проблему подключения:**
- План явно упоминает проблему "работает с 5-й попытки" и предлагает решения (проверка audioContext.state, resume(), детальное логирование)
- Это соответствует примечанию в project_state.md (строка 119): "Проблема подключения датчика: В нашем приложении работал только с 5-й попытки"

### Что исправлено после первого ревью

✅ **Добавлены критичные методы:**
- `disconnect()` — добавлен с полной очисткой ресурсов (строки 63-72)
- `getStatus()` — добавлен (строки 101-110)
- `getType()` — добавлен (строки 113-118)

✅ **Добавлена обработка edge cases:**
- Очистка ресурсов в `disconnect()` (строки 67-70)
- Обработка отзыва разрешения (строки 121-129)
- Проверка `audioContext.state` в `_processAudio()` (строка 81)
- Проверка `hitCallback` перед вызовом (строка 80)
- Проверка `mediaStream` на null (строка 55)
- Инициализация `dataArray` (строка 58)
- Try-catch в `_processAudio()` (строки 83-97)

### Оставшиеся пробелы

#### Критичные пробелы (блокируют реализацию):

1. **Отсутствует алгоритм метода `onHit(callback)`** → Нужно добавить в Slice 1:
   - Метод упомянут в структуре класса (строка 44), но его реализация не описана
   - KeyboardSensor имеет этот метод (строки 58-61)
   - Должен просто сохранять callback: `this.hitCallback = callback`

2. **Отсутствует реализация метода `_getMaxAmplitude()`** → Нужно добавить в Slice 1:
   - Метод используется в `_processAudio()` (строка 87), но не описан
   - Должен вычислять максимальное отклонение от 128 в `dataArray` и нормализовать к 0-1
   - Алгоритм: найти max(|value - 128|) для всех элементов, разделить на 127

#### Важные пробелы (могут вызвать проблемы в продакшене):

3. **Несоответствие сигнатуры `SensorManager.create()`** → Исправить в Slice 2:
   - В плане указано: `return new MicrophoneSensor(options)` (строка 150)
   - Но `SensorManager.create(type)` не принимает `options` — только `type`
   - Решение: либо изменить сигнатуру `SensorManager.create(type, options)`, либо передавать пустой объект `{}`, либо убрать `options` из конструктора MicrophoneSensor (использовать значения по умолчанию)

4. **Нет установки `this.connected = true` в `connect()`** → Добавить в алгоритм connect():
   - После успешного подключения нужно установить `this.connected = true`
   - В алгоритме (строки 50-61) это не указано явно

5. **Нет обработки ошибок в `connect()`** → Добавить в алгоритм connect():
   - Нужно обработать ошибки `getUserMedia()` и установить `this.error`
   - Ошибки перечислены в таблице (строки 134-138), но не указано, где их обрабатывать

6. **Нет привязки контекста для `_processAudio`** → Уточнить в алгоритме connect():
   - При использовании `setInterval(_processAudio, 5ms)` нужно привязать `this`
   - Должно быть: `setInterval(() => this._processAudio(), 5ms)` или `this._processAudio = this._processAudio.bind(this)`

### Конфликты с существующей архитектурой

⚠️ **Потенциальный конфликт:**
- В Slice 2 указано `return new MicrophoneSensor(options)`, но `SensorManager.create()` не принимает `options`
- Нужно либо изменить сигнатуру `SensorManager.create()`, либо убрать `options` из вызова

### Рекомендации для доработки

1. **В Slice 1, после алгоритма `getType()`:**
   - Добавить раздел "Алгоритм onHit()":
     ```javascript
     onHit(callback) {
       this.hitCallback = callback
       console.log('[MicrophoneSensor] Hit callback registered')
     }
     ```

2. **В Slice 1, после алгоритма `_processAudio()`:**
   - Добавить раздел "Алгоритм _getMaxAmplitude()":
     ```javascript
     _getMaxAmplitude() {
       let maxDeviation = 0
       for (let i = 0; i < this.dataArray.length; i++) {
         const deviation = Math.abs(this.dataArray[i] - 128)
         if (deviation > maxDeviation) {
           maxDeviation = deviation
         }
       }
       // Нормализовать к 0-1 (128 = тишина, 0 или 255 = максимум)
       return maxDeviation / 127
     }
     ```

3. **В Slice 1, алгоритм `connect()`:**
   - Добавить в конец (после шага 9): "11. Установить `this.connected = true`"
   - Добавить обработку ошибок: обернуть `getUserMedia()` в try-catch, установить `this.error` согласно таблице ошибок

4. **В Slice 1, алгоритм `connect()`, шаг 9:**
   - Уточнить: `setInterval(() => this._processAudio(), 5ms)` (с привязкой контекста)

5. **В Slice 2:**
   - Исправить строку 150: `return new MicrophoneSensor({})` (пустой объект, так как SensorManager.create() не принимает options)
   - Или изменить сигнатуру `SensorManager.create(type, options = {})` и обновить все вызовы в app.js

### Дополнительные замечания

- **Параметры детекции:** План правильно указывает, что параметры TBD при тестировании. Это соответствует подходу проекта.
- **Логирование:** План предусматривает детальное логирование, что соответствует требованию из project_state.md (строка 119).
- **Верификация:** Раздел верификации хорошо структурирован и покрывает основные сценарии, включая обработку отзыва разрешения.

### Итоговая оценка

План значительно улучшен после первого ревью. Большинство критичных замечаний учтены. Остались **2 критичных пробела**:
1. Отсутствует алгоритм `onHit()` — метод используется в app.js
2. Отсутствует реализация `_getMaxAmplitude()` — метод вызывается в `_processAudio()`

Также есть **важное несоответствие** в Slice 2: `SensorManager.create()` не принимает `options`, но план предполагает их передачу.

После добавления недостающих алгоритмов и исправления несоответствия в Slice 2 план будет готов к реализации.
