# CLAUDE.MD

Базовые правила для всех проектов.

**Главный принцип:** Код должен быть простым, предсказуемым и понятным.

---

# ЧАСТЬ 1. БАЗОВЫЕ ПРАВИЛА

## 1. Качество кода
- Публичные функции с аннотациями типов.
- Современный синтаксис: `list[str]`, `str | None`. Запрещено: `List`, `Dict`, `Optional` из `typing`.
- Для структур данных и валидации — `Pydantic`. `dataclass` допустим для простых случаев без валидации.
- Работа с файлами: `pathlib.Path`, всегда `encoding="utf-8"`.
- Данные: числа — числа, отсутствие — `None`, без магических значений.

## 2. Читаемость
- Максимум 4 уровня вложенности.
- Guard clauses вместо вложенных `if`.
- Одна функция = одна ответственность.

## 3. Архитектура
- Запрещены абстракции "на будущее" (допустимы при 2+ реальных реализациях).
- I/O отдельно от бизнес-логики.
- Слои: `entrypoints` → `domain` → `infra`.

## 4. Работа с LLM
Принцип: **Dumb Pipe → Smart Reasoner → Deterministic Output**

- LLM принимает решения и генерирует текст, но не парсит и не валидирует.
- Входы/выходы LLM — Pydantic модели с явным контрактом.
- Формат ответа описан жёстко; поля "из головы" запрещены.
- Запрещено парсить ответ LLM регулярками.
- Если ответ невалиден — выбрасывать ошибку, не пытаться "угадать".

## 5. Ошибки и логи
- Валидация входов на границах системы.
- Ошибки не подавляются молча; `raise ... from e` сохраняет контекст.
- Логи через `logging`, без секретов; логи помогают восстановить цепочку событий.

## 6. Перед коммитом
- Линтер и тесты проходят.
- Нет закомментированного кода и временных костылей.
- TODO только с причиной.
- `.env.example` актуален (все переменные окружения, без секретов).

---

# ЧАСТЬ 2. ПРОЦЕСС РАЗРАБОТКИ

## 1. Коммуникация
- Если решение неочевидно — объясни перед написанием кода.
- Объяснения понятны человеку без бэкграунда разработки.
- Если архитектура усложняется — остановись и предложи упрощение.

## 2. Стоп-кран
- 3 неудачные попытки исправить ошибку — **СТОП**.
- Не писать код дальше. Проанализировать, предложить другой подход.

## 3. User Stories
- **Перед началом Story:** EnterPlanMode для планирования.
- **План только для одной Story**, не для всего проекта.
- **Как только план готов:** СРАЗУ сохранить в `docs/plans/US-XXX-название.md`. Дальнейшее обсуждение и ревью плана ведётся по этому файлу. При изменениях — обновлять файл.
- **При старте Story:** обновить `project_state.md` → Current Sprint.
- **После коммита:** обновить `docs/user_stories.json` (`passes: true`) и `project_state.md` (Done).
- **Коммиты:** НИКОГДА не коммитить без явного разрешения ("ок", "коммитим", "да").

## 4. Ревью
План и код проходят ревью. Как работать с результатами:
- **Не выполнять слепо все замечания.** Ревьюер может ошибаться или не знать контекста.
- **Приоритизировать:** критичное (баги, нарушение архитектуры) vs мелкие улучшения.
- **Прокомментировать:** кратко ответить на каждое замечание — согласен/не согласен и почему.
- **Спорные моменты** обсудить с пользователем перед внесением изменений.
- **Ты — автор** и несёшь ответственность за решение. Финальное слово за тобой (с учётом мнения пользователя).

---

# ЧАСТЬ 3. КОНТЕКСТ ПРОЕКТА

## Проект
Beat Buddy — веб-приложение для тренировки чувства ритма у детей 3-15 лет. Ребёнок под руководством педагога слушает метроном в наушниках и бьёт по датчику на перчатке, получая визуальную обратную связь через анимацию.

**Детали:** см. [docs/prd.md](docs/prd.md)

## Специфичные правила

### 1. Web Audio API
- Низкая задержка аудио критична (<10ms для метронома)
- Используй `AudioContext` с `currentTime` для точного тайминга
- Избегай `setTimeout`/`setInterval` для аудио — только Web Audio API scheduling

### 2. Датчик удара
- Датчик подключён через мини-джек как микрофон
- Реагирует только на прямой удар (нет фоновых шумов)
- Обработка через `navigator.mediaDevices.getUserMedia()` и `AudioContext.createMediaStreamSource()`
- **КРИТИЧНО:** Логика подключения ОБЯЗАТЕЛЬНО в отдельном модуле (`SensorManager.js`)
  - При тестировании работал только с 5-й попытки в нашем приложении
  - В системе и на сторонних сайтах работает с 1-го раза
  - Проблема в нашем коде подключения, не в датчике/браузере
  - Модуль должен: логировать события, иметь чёткий API, легко тестироваться
  - Запрещено размазывать логику подключения по всему приложению
- **Две реализации датчика:**
  - `KeyboardSensor` — для разработки (пробел = удар), датчик приедет через 1-2 дня
  - `MicrophoneSensor` — для продакшена (реальный датчик)
  - Переключение между ними должно быть тривиальным (конфиг или UI)

### 3. UI для детей
- Большие кнопки (минимум 60px высота)
- Яркие цвета, чёткий контраст
- Минимум текста, максимум визуальной обратной связи
- Простая навигация (не больше 2 кликов до начала занятия)
